Redis底层采用C语言编写

## Redis为什么这么快

1. Redis是基于内存操作的
2. Redis基于Reactor模式设计开发了一套高效的事务处理模型——单线程事件循环和IO多路复用
3. Redis对内置的数据结构进行了优化，性能很高
4. Redis通信协议实现简单且通信高效

## Redis类型

### 基础类型

5种：String、List、Set、Hash、Zset(有序集合)
![[Pasted image 20240415151938.png]]

String:
- 底层使用SDS（Simple Dynamic String，简单动态字符串）
- 用来存储字符串、整数、浮点数、图片（路径或编码）、序列化后的对象
- 应用场景：
	- 常规数据存储：缓存Session、Token、图片地址、序列化后的对象
	- 计数：用户单位时间的请求数（用于简单限流）、页面单位时间访问次数

List:
- 底层实现为双向链表
- 应用场景： 
	- 信息流展示：最新文章、最新动态

Hash:一个 String 类型的 field-value（键值对） 的映射表
- 底层实现类似于JDK1.8前的HashMap，不过做了更多优化
- 应用场景： 
	- 对象数据存储：用户信息、商品信息、文章信息、购物车信息
> 相比于String的对象数据存储，Hash更适用于对象属性频繁变更的场景

Set：
- 应用场景： 
	- 集合场景：网站UV统计、文章点赞、动态点赞
	- 集合操作场景：共同关注、好友推荐、订阅号推荐
	- 抽奖

Zset：
- 底层实现使用**跳表**
- 应用场景： 
	- 排序场景：排行榜

#### 为什么使用Zset跳表不使用二叉平衡树、红黑树、B+树

跳表
- 多级索引
- 随机维护索引

跳表相对于：
- 二叉平衡树：查询性能相近，但插入与删除性能更优，且实现更简单
- 红黑树：查询、插入、删除性能相近，但实现更简单，区间查询性能更优
- B+树：B+树更适合作为数据库和文件系统中常用的索引结构之一，适用于尽量少的IO请求定位到尽量多的索引来获取查询数据，但Redis基于内存不可能存储大量数据，所以索引通过概率的方式进行随机维护，节约内存，且使用跳表实现更简单

## Redis持久化机制 #重要 

Redis持久化目的：
- 重用数据（重启或机器故障之后恢复数据）
- 数据同步（主从节点之间）

3种持久化方式：
- 快照（snapshotting，RDB）——默认采用的方式
- 只追加文件（append-onlf file， AOF）
- RDB和AOF混合持久化（Redis 4.0）

### RDB持久化

通过快照来获取Redis存储在内存中的数据的**某个时间点**的副本

快照可以复制给其他服务器从而创建一个相同数据的服务器副本
也可重启服务器时使用

Redis提供两个命令来创建快照
- save：会阻塞主线程
- bgsave：fork一个子进程来创建快照，不会阻塞 Redis 主线程，默认选项。

### AOF持久化

AOF实时性更好

AOF工作基本流程
- 命令追加：所有写命令会追加到AOD缓冲区
- 文件写入：写入系统内核缓冲区（延迟写，未写入磁盘）
- 文件同步：调用`fsync`实现缓存和磁盘同步，同步时机由`fsync` 策略决定
- 文件重写：定期对AOF文件重写，以节省空间
- 重启加载：当Redis重启时，可加载AOF文件重写

AOF持久化方式（`fsync` 策略）：
- 执行完写命令立马写入并同步（主线程`write`后后台线程立马调用`fsync`
- 后台线程每秒调用`fsync`进行同步
- 由操作系统决定，Linux 下一般为 30 秒一次

AOF总是在命令执行完后记录日志：
- 避免额外的检查开销，AOF记录日志不会进行命令语法检查
- 不会阻塞当前命令的执行
存在风险：
- 可能会出现修改丢失
- 阻塞其他命令的执行（AOF记录日志在主线程中进行）

AOF重写：Redis 能够在后台自动重写 AOF 产生一个新的 AOF 文件，这个新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。

AOF使用**校验和**来验证AOF文件

### RDB和AOF混合持久化

混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头

### RDB 和 AOF 选择

RDB：
- 文件存储的内容是经过压缩的二进制数据，
- 恢复数据直接解析还原即可，不需要一条一条命令执行

AOF： 
- 更安全可靠，支持秒级数据丢失，操作轻量，RDB文件生成过程对性能消耗比较大
- RDB可能存在新老版本不兼容问题
- AOF的格式更易于理解和解析

> 不建议单独使用 AOF，因为时不时地创建一个 RDB 快照可以进行数据库备份、更快的重启以及解决 AOF 引擎错误。

## Redis线程模型 #重要 

对于读写命令，Redis一直保持**单线程模式**，在Redis4.0，引入多线程处理大键值对的异步删除操作，Redis6.0引入多线程来处理网络请求（提高网络IO读写性能）

### Redis6.0之前为什么不引入多线程

（Redis4.0引入了多线程处理大键值对的异步删除操作）

- 单线程编程简单且更容易维护
- Redis的性能瓶颈不在CPU，而在内存和网络
- 多线程存在死锁和上下文切换等问题，影响性能

### Redis6.0为什么引入多线程

为了提高网络IO读写性能

### Redis后台线程

-  `bio_close_file`：释放 AOF/RDB 等过程中产生的临时文件资源
-  `bio_aof_fsync`：调用`fsync`完成系统内核缓冲区与磁盘的同步
-  `bio_lazy_free`：释放大对象（已删除）占用的空间

## Redis事务

很鸡肋

Redis事务可以将一批命令打包，然后按顺序执行该批命令，且不会被打断，但是事务中的每条命令都会与Redis服务器进行网络交互(所以很鸡肋)，不能节省网络传输时间
> 不会被打断不代表是原子性，因为如果事务中途结束，执行过的命令不会被撤销，因为Redis不支持回滚操作

## Redis内存管理

Redis如何判断数据过期：过期字典（键，过期时间戳），里面存的不是过期的Key，而是Key的过期时间

### 过期对象删除策略

- 定时删除：给Key设定过期时间时，设定一个定时任务来删除该Key
- 惰性删除：在取出Key时进行过期检查，过期则删除，这样对CPU友好，但会存在过期Key未被删除
- 定期删除：每隔一段时间取出一定数量Key进行过期检查，Redis会限制删除操作的时长和频率来减少对CPU的影响 
Redis 采用的是 **定期删除+惰性/懒汉式删除** 。
定期删除是主线程操作，惰性删除时子线程操作

定期删除流程：
1. 从过期字典里随机抽取20个Key
2. 检查是否过期，并删除过期Key
3. 若过期Key数量超过5个，则继续重复步骤1，直到达到定期删除执行时间上限

### Redis内存淘汰机制：

- **volatile-lru（least recently used）**：Redis默认选项
- **volatile-ttl**：挑选即将过期的淘汰
- **volatile-random**：
- **allkeys-lru（least recently used）**
- **allkeys-random**
- **no-eviction**：禁止驱逐数据
- **volatile-lfu（least frequently used）**：最不常使用
- **allkeys-lfu（least frequently used）**
> **volatile**：在设置了过期时间的Key中挑选
> **allkeys**：在所有Key中挑选

## Redis性能优化

### 使用批量操作减少网络传输

Redis命令的操作流程可以视为：
1. 发出命令
2. 命令排队
3. 命令执行
4. 返回结果
其中1、4都需要在网络中进行传输，批量传输命令可以减少**网络传输时间**，同时也能减少**Socket IO的成本**

#### 批量操作

##### 原生批量操作命令

MGET、MSET、HMGET、HMSET......

在 Redis 官方提供的分片集群解决方案 Redis Cluster 下，这些原生批量操作命令存在一些问题，比如`MGET` 无法保证所有的 key 都在同一个 **hash slot**（哈希槽）上（pipeline和Lua脚本都存在相同问题
`MGET`可能还是需要多次网络传输，原子操作也无法保证了

> [[Hash#Hash Slot]]

##### pipeline

对于不支持批量操作的命令，我们可以利用 **pipeline（流水线)** 将一批 Redis 命令封装成一组，这些 Redis 命令会被一次性提交到 Redis 服务器，只需要一次网络传输。

同样存在`MGET` 的问题

原生批量操作命令是原子性的，pipeline不是

pipeline无法保证命令是顺序执行的，对于这种需求可以采用Lua脚本

##### Lua脚本

支持批量操作命令，且是原子操作（不会被打断）

依然存在问题：
- 不支持类似回滚的原子性
- 在 Redis Cluster 下，原子操作失效

### 大量Key集中过期

该情况下，定期删除线程的执行时间会变长（达到时间上限），客户端请求响应变慢（甚至让客户端请求过期

解决方法：
- 给 key 设置随机过期时间。
- 开启Lazy-free。lazy-free 特性是 Redis 4.0 开始引入的，指的是让 Redis 采用异步方式延迟释放 key 使用的内存，将该操作交给单独的子线程处理，避免阻塞主线程。

### Redis大Key

#### 什么是大Key

粗略评估：
- String类型的value超过1MB
- 复合类型的value包括的元素超过5000个

#### 大Key产生原因

- 程序设计不当，比如直接使用String类型存储大文件的二进制数据
- 业务规模估计不当，比如集合类型没有考虑到数据的大量增长
- 未及时清理垃圾数据，比如hash中存了大量无用数据

#### 大Key会造成阻塞问题

- 客户端阻塞：处理大Key时间长，客户端请求响应慢
- 网络阻塞：大Key在网络中传输产生的流量大
- 工作线程阻塞：如果使用 del 删除大 key 时，会阻塞工作线程，这样就没办法处理后续的命令

#### 如何发现bigKey

1. 使用Redis自带的--bigkeys参数
2. 使用Redis自带的SCAN命令
3. 借助开源工具分析RDB文件
4. 借助公有云的 Redis 分析服务

#### 如何处理bigKey

1. 分割bigKey
2. 手动清理
3. 采用合适的数据结构
4. 开启lazy-free

### Redis热Key（hotKey）

#### 什么是hotKey

一个 key 的访问次数比较多且明显多于其他 key 的话，那这个 key 就可以看作是 **hotkey**

出现原因：某个热点数据访问量激增，如重大热搜、秒杀商品

#### hotKey的危害

- 影响其他Key的请求性能
- 可能造成Redis宕机

#### 如何发现hotKey

1. **使用 Redis 自带的 `--hotkeys` 参数来查找。**（需要开启内存淘汰测类的 LFU 算法）
2. **使用`MONITOR` 命令**（对Redis性能影响大 
3. **借助开源项目**（京东hotkey
4. **根据业务情况提前预估。**
5. **业务代码中记录分析。**
6. **借助公有云的 Redis 分析服务。**

#### 如何解决hotKey

（可搭配使用）
1. 读写分离：主节点处理写请求，从节点处理读请求
2. 使用Redis Cluster：将热点数据分布到多个节点
3. 二级缓存：将 hotkey 存放一份到 JVM 本地内存中

### 慢查询问题

Redis 慢查询统计的是命令执行这一步骤的耗时，慢查询命令也就是那些命令执行时间较长的命令