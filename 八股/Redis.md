Redis底层采用C语言编写

## Redis为什么这么快

1. Redis是基于内存操作的
2. Redis基于Reactor模式设计开发了一套高效的事务处理模型——单线程事件循环和IO多路复用
3. Redis对内置的数据结构进行了优化，性能很高
4. Redis通信协议实现简单且通信高效

## Redis类型

### 基础类型

5种：String、List、Set、Hash、Zset(有序集合)
![[Pasted image 20240415151938.png]]

String:
- 底层使用SDS（Simple Dynamic String，简单动态字符串）
- 用来存储字符串、整数、浮点数、图片（路径或编码）、序列化后的对象
- 应用场景：
	- 常规数据存储：缓存Session、Token、图片地址、序列化后的对象
	- 计数：用户单位时间的请求数（用于简单限流）、页面单位时间访问次数

List:
- 底层实现为双向链表
- 应用场景： 
	- 信息流展示：最新文章、最新动态

Hash:一个 String 类型的 field-value（键值对） 的映射表
- 底层实现类似于JDK1.8前的HashMap，不过做了更多优化
- 应用场景： 
	- 对象数据存储：用户信息、商品信息、文章信息、购物车信息
> 相比于String的对象数据存储，Hash更适用于对象属性频繁变更的场景

Set：
- 应用场景： 
	- 集合场景：网站UV统计、文章点赞、动态点赞
	- 集合操作场景：共同关注、好友推荐、订阅号推荐
	- 抽奖

Zset：
- 底层实现使用**跳表**
- 应用场景： 
	- 排序场景：排行榜

#### 为什么使用Zset跳表不使用二叉平衡树、红黑树、B+树

跳表
- 多级索引
- 随机维护索引

跳表相对于：
- 二叉平衡树：查询性能相近，但插入与删除性能更优，且实现更简单
- 红黑树：查询、插入、删除性能相近，但实现更简单，区间查询性能更优
- B+树：B+树更适合作为数据库和文件系统中常用的索引结构之一，适用于尽量少的IO请求定位到尽量多的索引来获取查询数据，但Redis基于内存不可能存储大量数据，所以索引通过概率的方式进行随机维护，节约内存，且使用跳表实现更简单

## Redis持久化机制 #重要 

Redis持久化目的：
- 重用数据（重启或机器故障之后恢复数据）
- 数据同步（主从节点之间）

3种持久化方式：
- 快照（snapshotting，RDB）——默认采用的方式
- 只追加文件（append-onlf file， AOF）
- RDB和AOF混合持久化（Redis 4.0）

### RDB持久化

通过快照来获取Redis存储在内存中的数据的**某个时间点**的副本

快照可以复制给其他服务器从而创建一个相同数据的服务器副本
也可重启服务器时使用

Redis提供两个命令来创建快照
- save：会阻塞主线程
- bgsave：fork一个子进程来创建快照，不会阻塞 Redis 主线程，默认选项。

### AOF持久化

AOF实时性更好

AOF工作基本流程
- 命令追加：所有写命令会追加到AOD缓冲区
- 文件写入：写入系统内核缓冲区（延迟写，未写入磁盘）
- 文件同步：调用`fsync`实现缓存和磁盘同步，同步时机由`fsync` 策略决定
- 文件重写：定期对AOF文件重写，以节省空间
- 重启加载：当Redis重启时，可加载AOF文件重写

AOF持久化方式（`fsync` 策略）：
- 执行完写命令立马写入并同步（主线程`write`后后台线程立马调用`fsync`
- 后台线程每秒调用`fsync`进行同步
- 由操作系统决定，Linux 下一般为 30 秒一次

AOF总是在命令执行完后记录日志：
- 避免额外的检查开销，AOF记录日志不会进行命令语法检查
- 不会阻塞当前命令的执行
存在风险：
- 可能会出现修改丢失
- 阻塞其他命令的执行（AOF记录日志在主线程中进行）

AOF重写：Redis 能够在后台自动重写 AOF 产生一个新的 AOF 文件，这个新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。

AOF使用**校验和**来验证AOF文件

### RDB和AOF混合持久化

混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头

### RDB 和 AOF 选择

RDB：
- 文件存储的内容是经过压缩的二进制数据，
- 恢复数据直接解析还原即可，不需要一条一条命令执行

AOF： 
- 更安全可靠，支持秒级数据丢失，操作轻量，RDB文件生成过程对性能消耗比较大
- RDB可能存在新老版本不兼容问题
- AOF的格式更易于理解和解析

> 不建议单独使用 AOF，因为时不时地创建一个 RDB 快照可以进行数据库备份、更快的重启以及解决 AOF 引擎错误。

## Redis线程模型 #重要 

对于读写命令，Redis一直保持**单线程模式**，在Redis4.0，引入多线程处理大键值对的异步删除操作，Redis6.0引入多线程来处理网络请求（提高网络IO读写性能）

### Redis6.0之前为什么不引入多线程

（Redis4.0引入了多线程处理大键值对的异步删除操作）

- 单线程编程简单且更容易维护
- Redis的性能瓶颈不在CPU，而在内存和网络
- 多线程存在死锁和上下文切换等问题，影响性能

### Redis6.0为什么引入多线程

为了提高网络IO读写性能

### Redis后台线程

-  `bio_close_file`：释放 AOF/RDB 等过程中产生的临时文件资源
-  `bio_aof_fsync`：调用`fsync`完成系统内核缓冲区与磁盘的同步
-  `bio_lazy_free`：释放大对象（已删除）占用的空间

## Redis内存管理

Redis如何判断数据过期：过期字典（键，过期时间戳）

过期对象删除策略：
- 惰性删除：在取出Key时进行过期检查，过期则删除，这样对CPU友好，但会存在过期Key未被删除
- 定期删除：每隔一段时间取出一批Key进行过期检查，Redis会限制删除操作的时长和频率来减少对CPU的影响
Redis 采用的是 **定期删除+惰性/懒汉式删除** 。

Redis内存淘汰机制：
- **volatile-lru（least recently used）**
- **volatile-ttl**：挑选即将过期的淘汰
- **volatile-random**：
- **allkeys-lru（least recently used）**
- **allkeys-random**
- **no-eviction**：禁止驱逐数据
- **volatile-lfu（least frequently used）**：最不常使用
- **allkeys-lfu（least frequently used）**
> **volatile**：在设置了过期时间的Key中挑选
> **allkeys**：在所有Key中挑选

## Redis性能优化

