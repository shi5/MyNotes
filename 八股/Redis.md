Redis底层采用C语言编写

## Redis为什么这么快

1. Redis是基于内存操作的
2. Redis基于Reactor模式设计开发了一套高效的事务处理模型——单线程事件循环和IO多路复用
3. Redis对内置的数据结构进行了优化，性能很高
4. Redis通信协议实现简单且通信高效

## Redis类型

### 基础类型

5种：String、List、Set、Hash、Zset(有序集合)
![[Pasted image 20240415151938.png]]

String:
- 底层使用SDS（Simple Dynamic String，简单动态字符串）
- 用来存储字符串、整数、浮点数、图片（路径或编码）、序列化后的对象
- 应用场景：
	- 常规数据存储：缓存Session、Token、图片地址、序列化后的对象
	- 计数：用户单位时间的请求数（用于简单限流）、页面单位时间访问次数

List:
- 底层实现为双向链表
- 应用场景： 
	- 信息流展示：最新文章、最新动态

Hash:一个 String 类型的 field-value（键值对） 的映射表
- 底层实现类似于JDK1.8前的HashMap，不过做了更多优化
- 应用场景： 
	- 对象数据存储：用户信息、商品信息、文章信息、购物车信息
> 相比于String的对象数据存储，Hash更适用于对象属性频繁变更的场景

Set：
- 应用场景： 
	- 集合场景：网站UV统计、文章点赞、动态点赞
	- 集合操作场景：共同关注、好友推荐、订阅号推荐
	- 抽奖

Zset：
- 底层实现使用**跳表**
- 应用场景： 
	- 排序场景：排行榜

#### 为什么使用Zset跳表不使用二叉平衡树、红黑树、B+树

跳表
- 多级索引
- 随机维护索引

跳表相对于：
- 二叉平衡树：查询性能相近，但插入与删除性能更优，且实现更简单
- 红黑树：查询、插入、删除性能相近，但实现更简单，区间查询性能更优
- B+树：B+树更适合作为数据库和文件系统中常用的索引结构之一，适用于尽量少的IO请求定位到尽量多的索引来获取查询数据，但Redis基于内存不可能存储大量数据，所以索引通过概率的方式进行随机维护，节约内存，且使用跳表实现更简单

## Redis持久化机制 #重要 

Redis持久化目的：
- 重用数据（重启或机器故障之后恢复数据）
- 数据同步（主从节点之间）

3种持久化方式：
- 快照（snapshotting，RDB）——默认采用的方式
- 只追加文件（append-onlf file， AOF）
- RDB和AOF混合持久化（Redis 4.0）

### RDB持久化

通过快照来获取Redis存储在内存中的数据的**某个时间点**的副本

快照可以复制给其他服务器从而创建一个相同数据的服务器副本
也可重启服务器时使用

Redis提供两个命令来创建快照
- save：会阻塞主线程
- bgsave：fork一个子进程来创建快照，不会阻塞 Redis 主线程，默认选项。

### AOF持久化

AOF实时性更好

AOF工作基本流程
- 命令追加：所有写命令会追加到AOD缓冲区
- 文件写入：写入系统内核缓冲区（延迟写，未写入磁盘）
- 文件同步：调用`fsync`实现缓存和磁盘同步，同步时机由`fsync` 策略决定
- 文件重写：定期对AOF文件重写，以节省空间
- 重启加载：当Redis重启时，可加载AOF文件重写

AOF持久化方式（`fsync` 策略）：
- 执行完写命令立马写入并同步（主线程`write`后后台线程立马调用`fsync`
- 后台线程每秒调用`fsync`进行同步
- 由操作系统决定，Linux 下一般为 30 秒一次

AOF总是在命令执行完后记录日志：
- 避免额外的检查开销，AOF记录日志不会进行命令语法检查
- 不会阻塞当前命令的执行
存在风险：
- 可能会出现修改丢失
- 阻塞其他命令的执行（AOF记录日志在主线程中进行）

AOF重写：Redis 能够在后台自动重写 AOF 产生一个新的 AOF 文件，这个新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。

AOF使用**校验和**来验证AOF文件

### RDB和AOF混合持久化

混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头

### RDB 和 AOF 选择

RDB：
- 文件存储的内容是经过压缩的二进制数据，
- 恢复数据直接解析还原即可，不需要一条一条命令执行

AOF： 
- 更安全可靠，支持秒级数据丢失，操作轻量，RDB文件生成过程对性能消耗比较大
- RDB可能存在新老版本不兼容问题
- AOF的格式更易于理解和解析

> 不建议单独使用 AOF，因为时不时地创建一个 RDB 快照可以进行数据库备份、更快的重启以及解决 AOF 引擎错误。

## Redis线程模型 #重要 

对于读写命令，Redis一直保持**单线程模式**，在Redis4.0，引入多线程处理大键值对的异步删除操作，Redis6.0引入多线程来处理网络请求（提高网络IO读写性能）

### Redis6.0之前为什么不引入多线程

（Redis4.0引入了多线程处理大键值对的异步删除操作）

- 单线程编程简单且更容易维护
- Redis的性能瓶颈不在CPU，而在内存和网络
- 多线程存在死锁和上下文切换等问题，影响性能

### Redis6.0为什么引入多线程

为了提高网络IO读写性能

### Redis后台线程

-  `bio_close_file`：释放 AOF/RDB 等过程中产生的临时文件资源
-  `bio_aof_fsync`：调用`fsync`完成系统内核缓冲区与磁盘的同步
-  `bio_lazy_free`：释放大对象（已删除）占用的空间

## Redis事务

很鸡肋

Redis事务可以将一批命令打包，然后按顺序执行该批命令，且不会被打断，但是事务中的每条命令都会与Redis服务器进行网络交互(所以很鸡肋)，不能节省网络传输时间
> 不会被打断不代表是原子性，因为如果事务中途结束，执行过的命令不会被撤销，因为Redis不支持回滚操作

## Redis内存管理

Redis如何判断数据过期：过期字典（键，过期时间戳），里面存的不是过期的Key，而是Key的过期时间

### 过期对象删除策略

- 定时删除：给Key设定过期时间时，设定一个定时任务来删除该Key
- 惰性删除：在取出Key时进行过期检查，过期则删除，这样对CPU友好，但会存在过期Key未被删除
- 定期删除：每隔一段时间取出一定数量Key进行过期检查，Redis会限制删除操作的时长和频率来减少对CPU的影响 
Redis 采用的是 **定期删除+惰性/懒汉式删除** 。
定期删除是主线程操作，惰性删除时子线程操作

定期删除流程：
1. 从过期字典里随机抽取20个Key
2. 检查是否过期，并删除过期Key
3. 若过期Key数量超过5个，则继续重复步骤1，直到达到定期删除执行时间上限

### Redis内存淘汰机制：

- **volatile-lru（least recently used）**：Redis默认选项
- **volatile-ttl**：挑选即将过期的淘汰
- **volatile-random**：
- **allkeys-lru（least recently used）**
- **allkeys-random**
- **no-eviction**：禁止驱逐数据
- **volatile-lfu（least frequently used）**：最不常使用
- **allkeys-lfu（least frequently used）**
> **volatile**：在设置了过期时间的Key中挑选
> **allkeys**：在所有Key中挑选

#### Redis实现的lru

近似lru：
- 存储时间戳
- 每次随机选取5个（可设定），淘汰最久没使用的
- 无法解决缓存污染

#### Redis实现的lfu

LFU 算法相比于 LRU 算法的实现，多记录了「数据的访问频次」的信息。

Redis对象头的 24 bits 的 lru 字段被分成两段来存储，高 16bit 存储 ldt(Last Decrement Time)，低 8bit 存储 logc(Logistic Counter)

ldt记录时间戳
logc记录**使用频率**，根据这个值来淘汰

logc的变化会考虑访问的时间差（和时间戳作比较）对logc进行**衰减**，同时再按照一定概率增加 logc 的值
## Redis性能优化

### 使用批量操作减少网络传输

Redis命令的操作流程可以视为：
1. 发出命令
2. 命令排队
3. 命令执行
4. 返回结果
其中1、4都需要在网络中进行传输，批量传输命令可以减少**网络传输时间**，同时也能减少**Socket IO的成本**

#### 批量操作

##### 原生批量操作命令

MGET、MSET、HMGET、HMSET......

在 Redis 官方提供的分片集群解决方案 Redis Cluster 下，这些原生批量操作命令存在一些问题，比如`MGET` 无法保证所有的 key 都在同一个 **hash slot**（哈希槽）上（pipeline和Lua脚本都存在相同问题
`MGET`可能还是需要多次网络传输，原子操作也无法保证了

> [[Hash#Hash Slot]]

##### pipeline

对于不支持批量操作的命令，我们可以利用 **pipeline（流水线)** 将一批 Redis 命令封装成一组，这些 Redis 命令会被一次性提交到 Redis 服务器，只需要一次网络传输。

同样存在`MGET` 的问题

原生批量操作命令是原子性的，pipeline不是

pipeline无法保证命令是顺序执行的，对于这种需求可以采用Lua脚本

##### Lua脚本

支持批量操作命令，且是原子操作（不会被打断）

依然存在问题：
- 不支持类似回滚的原子性
- 在 Redis Cluster 下，原子操作失效

### 大量Key集中过期

该情况下，定期删除线程的执行时间会变长（达到时间上限），客户端请求响应变慢（甚至让客户端请求过期

解决方法：
- 给 key 设置随机过期时间。
- 开启Lazy-free。lazy-free 特性是 Redis 4.0 开始引入的，指的是让 Redis 采用异步方式延迟释放 key 使用的内存，将该操作交给单独的子线程处理，避免阻塞主线程。

### Redis大Key

#### 什么是大Key

粗略评估：
- String类型的value超过1MB
- 复合类型的value包括的元素超过5000个

#### 大Key产生原因

- 程序设计不当，比如直接使用String类型存储大文件的二进制数据
- 业务规模估计不当，比如集合类型没有考虑到数据的大量增长
- 未及时清理垃圾数据，比如hash中存了大量无用数据

#### 大Key会造成阻塞问题

- 客户端阻塞：处理大Key时间长，客户端请求响应慢
- 网络阻塞：大Key在网络中传输产生的流量大
- 工作线程阻塞：如果使用 del命令删除大 key 时，会阻塞工作线程，这样就没办法处理后续的命令

#### 如何发现bigKey

1. 使用Redis自带的--bigkeys参数
2. 使用Redis自带的SCAN命令
3. 借助开源工具分析RDB文件
4. 借助公有云的 Redis 分析服务

#### 如何处理bigKey

1. 分割bigKey
2. 手动清理
3. 采用合适的数据结构
4. 开启lazy-free

### Redis热Key（hotKey）

#### 什么是hotKey

一个 key 的访问次数比较多且明显多于其他 key 的话，那这个 key 就可以看作是 **hotkey**

出现原因：某个热点数据访问量激增，如重大热搜、秒杀商品

#### hotKey的危害

- 影响其他Key的请求性能
- 可能造成Redis宕机

#### 如何发现hotKey

1. **使用 Redis 自带的 `--hotkeys` 参数来查找。**（需要开启内存淘汰测类的 LFU 算法）
2. **使用`MONITOR` 命令**（对Redis性能影响大 
3. **借助开源项目**（京东hotkey
4. **根据业务情况提前预估。**
5. **业务代码中记录分析。**
6. **借助公有云的 Redis 分析服务。**

#### 如何解决hotKey

（可搭配使用）
1. 读写分离：主节点处理写请求，从节点处理读请求
2. 使用Redis Cluster：将热点数据分布到多个节点
3. 二级缓存：将 hotkey 存放一份到 JVM 本地内存中

### 慢查询问题

Redis 慢查询统计的是命令执行这一步骤的耗时，慢查询命令也就是那些命令执行时间较长的命令

#### 如何找到慢查询命令

在 `redis.conf` 文件中，我们可以使用 `slowlog-log-slower-than` 参数设置耗时命令的阈值，并使用 `slowlog-max-len` 参数设置耗时命令的最大记录条数。

### Redis内存碎片

不可用的空闲内存

#### 为什么会有Redis内存碎片

1. **Redis 存储数据的时候向操作系统申请的内存空间可能会大于数据实际需要的存储空间。**
2. **频繁修改 Redis 中的数据也会产生内存碎片。**

#### 如何查看Redis内存碎片的信息

使用 `info memory` 命令即可查看 Redis 内存相关的信息。

#### 如何清理

Redis4.0-RC3 版本以后自带了内存整理，可以通过设置参数对其控制

## Redis生产问题

### 缓存穿透 

1. 缓存无效Key
2. [[布隆过滤器]] 
3. 接口限流：根据用户和IP对接口限流

### 缓存击穿 

1. 热点数据永不过期或者过期时间比较长
2. 缓存预热
3. 互斥锁

### 缓存雪崩 

[[缓存穿透、缓存击穿、缓存雪崩#缓存雪崩 | 缓存雪崩]]

### 如何保证缓存和数据库的一致性

### Redis常见阻塞原因

- O(n)命令
- Save创建RDB快照
- AOF 
	- AOF日志记录阻塞
	- AOF刷盘阻塞
	- AOF重写阻塞
- 大Key 
- 清空数据库
- 集群扩容
- Swap（内存交换）/ 虚拟内存
- CPU竞争
- 网络问题

## 3种常用的缓存读写策略详解

### 旁路缓存模式（Cache Aside Pattern）

适合读请求多的场景

服务端需要同时维系 db 和 cache，并且是以 db 的结果为准

写：
- 先更新db
- 再删除cache

**在写数据的过程中，可以先删除 cache ，后更新 db 么？**
见 [[缓存和数据库一致性问题]]

读：
- cache存在直接读取
- cache不存在读db
- 将数据写入cache

### 读写穿透（Read/Write Through Pattern）

不常用

服务端把 cache 视为主要数据存储

写：
- 先查cache，cache不存在则直接更新db
- cache存在，先更新cache，然后cache服务自己更新db

读：
- cache存在直接读取返回
- 不存在则从db加载，写入cache后返回

### 异步缓存写入（Write Behind Pattern）

适合写请求多，适合一些数据经常变化又对数据一致性要求没那么高的场景，比如浏览量、点赞量。

和 Read/Write Through Pattern 很相似，由 cache 服务来负责 cache 和 db 的读写。

但是：**Read/Write Through 是同步更新 cache 和 db，而 Write Behind 则是只更新缓存，不直接更新 db，而是改为异步批量的方式来更新 db。**

## Redis集群

### Redis服务高可用

高可用要从Redis的多服务节点来考虑

#### 主从复制

主从复制是 Redis 高可用服务的最基础的保证，即一主多从，主从服务器之间采用“读写分离”的方式

![[Pasted image 20240417101435.png]]

主从服务器之间的命令复制是**异步**进行的

##### 主从复制的三种方式

1. 全量复制

出现在主从第一次同步，通过RDB文件进行同步
在生成RDB、传输RDB、恢复RDB的过程中，主节点会接收新的数据，这些数据会被写入replication-buffer（每个主从连接之间都有），然后将这些增量数据传输给从节点

在上述过程中，可以使用从节点来**分摊主节点的同步压力**，即同步好的从节点来将自己的数据同步给自己旗下的从节点

2. 基于长连接的命令传播

第一次同步完成后，主从节点之间同步保持TCP长连接，并通过该连接传播写操作命令

3. 增量复制

主从连接突然断开，然后又恢复，中间这部分的数据会通过增量复制进行同步

主节点中维护一个唯一的环形缓冲——**repl_backlog_buffer**，主节点会记录自己写的位置，从节点记录自己读的位置

从节点恢复连接的时候，会将自己读的位置传输给主节点，主节点根据这二者的关系判断采用哪种复制：
- 从节点要读的数据还在，采用**增量复制**
- 不在，采用**全量复制**

要避免全量复制，要好好斟酌**repl_backlog_buffer**区大小

##### 如何应对主从数据不一致

为什么会主从数据不一致？因为主从之间的采用异步复制，不能保证强一致性

1. 尽量保证主从网络状况良好
2. 采用外部程序监控主从节点间的复制进度

##### 主从切换如何减少数据丢失

两种情况：
1. 异步复制同步丢失
当主节点发现通信时长大于阈值时，那么禁止主节点进行写数据，直接把错误返回给客户端。

2. 集群产生脑裂数据丢失 
当主节点发现从节点总数量小于阈值或者通信时长大于阈值时，那么禁止主节点进行写数据，直接把错误返回给客户端。

#### 哨兵模式

解决Redis主从服务器故障宕机时，需要手动进行恢复的问题

哨兵模式可以监控主从服务器，并且提供**主从节点故障转移的功能。**

哨兵任务：监控、选主、通知

##### 如何判断主节点真的故障了

哨兵会每隔 1 秒给所有主从节点发送 PING 命令

如果主节点或者从节点没有在规定的时间内响应（单个）哨兵的 PING 命令，（单个）哨兵就会将它们标记为「**主观下线**」。（主节点还存在**客观下线**）

为了更加“客观”的判断主节点故障，哨兵一般都会部署多个

如何判断主节点客观下线：
当一个哨兵判断主节点为「主观下线」后，就会向其他哨兵发起命令，其他哨兵收到这个命令后，就会根据自身和主节点的网络状况，做出赞成投票或者拒绝投票的响应。赞同数超过哨兵配置文件中的 quorum 值时，会被该哨兵标记“客观下线”
> 哨兵配置文件中的 quorum 值一般为 哨兵数一半+1， **哨兵节点的数量应该是奇数**

哨兵判断完主节点客观下线后，哨兵就要开始在多个「从节点」中，选出一个从节点来做新主节点。

##### 哪个哨兵进行主从故障转移

需要选出leader来进行
判断主节点「客观下线」的哨兵是leader候选者，哨兵们从候选者中投票选出leader
赞同数必须在一半以上且大于等于哨兵配置文件中的 quorum 值。

##### 为什么哨兵至少需要3个

如果哨兵集群中只有 2 个哨兵节点，此时如果一个哨兵想要成功成为 Leader，必须获得 2 票，而不是 1 票。

所以，如果哨兵集群中有个哨兵挂掉了，那么就只剩一个哨兵了，如果这个哨兵想要成为 Leader，这时票数就没办法达到 2 票，就无法成功成为 Leader，这时是无法进行主从节点切换的。

##### 哨兵集群组成

通过发布者/订阅者机制

#### 切片集群模式

**Redis 切片集群**（Redis Cluster ）

Redis Cluster 方案采用哈希槽（Hash Slot），来处理数据和节点之间的映射关系。在 Redis Cluster 方案中，**一个切片集群共有 16384 个哈希槽**，这些哈希槽类似于数据分区，每个键值对都会根据它的 key，被映射到一个哈希槽中

![[Pasted image 20240417102939.png]]

### 集群脑裂导致数据丢失怎么办

#### 什么是脑裂

由于网络问题，主节点与从节点的失联，但和客户端保持联系，客户端会继续和主节点通信，但此时哨兵发现主节点失联，认为主节点挂掉了，会从节点重新选举出主服务节点，此时集群中存在两个主节点——这就是脑裂。

网路恢复后，旧主节点会降级为从节点，第一次主从同步会采用全量同步的方式，导致旧主节点缓存的修改全部丢失。

解决方案：
当主节点发现「从节点下线的数量太多」，或者「网络延迟太大」的时候，那么主节点会禁止写操作，直接把错误返回给客户端。

## Redis分布式锁
