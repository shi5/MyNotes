## MySQL结构

server + 存储引擎

Server：建立连接、分析和执行SQL
存储引擎：存储和读取数据

## select查询语句执行过程

1. 连接器
	- MySQL基于TCP，分为长连接和短链接
2. 查询缓存
	- server层会将之前查询的结果缓存
	- 比较鸡肋，8.0被删除
3. 解析SQL
	2. 解析器
		- 词法分析
		- 语法分析
1. 执行SQL
	1. 预处理器
		- 检查表或字段是否存在（8.0之前是在预处理之前）
		- 将`select *`中的`*`扩展为表上所有列
	2. 优化器：确定SQL查询的语句的执行方案
		- `explain`命令可以用于查看sql的执行方案
	1. 执行器
		- 主键索引查询
		- 全表扫描
		- 索引下推：在二级索引中判断条件

## 表空间结构

段-区-页-行

段：
- 索引段
- 数据段
- 回滚段

区：为了保证连续io

页：数据库的数据**按「页」为单位来读写的**
- 页与页之间双向链表连接
- 页内记录按照主键顺序组成单向链表
- 页目录起索引作用，页内记录会分组，页目录存储每个分组的最后一项记录的地址
> InnoDB 里的 B+ 树中的**每个节点都是一个数据页**

行：记录按行存放

### 行格式

4种行格式：
- Redundant（不常用）：不紧凑
- Compact（5.1）：紧凑行格式
- Dynamic（5.7）：基于Compact改进
- Compressed：基于Compact改进

#### Compact行格式

![[Pasted image 20240423205516.png]]

#### 行溢出处理方式

Compact：发生行溢出时，**多余数据会存到另外的「溢出页」中**，行记录中存储“部分数据+溢出页地址”
![[Pasted image 20240423205816.png]]

Compressed 和 Dynamic：**溢出数据全部存到「溢出页」**，行记录中存储“溢出页地址”

> 溢出页地址20字节

## 索引

### 索引分类

- 按「数据结构」分类：**B+tree索引、Hash索引、Full-text索引**。
- 按「物理存储」分类：**聚簇索引（主键索引）、二级索引（辅助索引）**。
- 按「字段特性」分类：**主键索引、唯一索引、普通索引、前缀索引**。
- 按「字段个数」分类：**单列索引、联合索引**。

### 索引选择

- 有主键，逐渐作为聚簇索引的索引键（key
- 没有主键，选取第一个不包含NULL的唯一列作为聚簇索引的索引键（key
- 上述都没有，InnoDB自动生成一个隐式自增 id 列作为聚簇索引的索引键（key

其他索引都属于辅助索引，也被称为二级索引或非聚簇索引

默认使用B+树作为索引的数据结构

### 联合索引

联合索引：多个字段组合成一个索引

- 存在先后顺序：(a,b,c)和(b,a,c)不一样
- 最左匹配原则

> 建立联合索引的时候要把**区分度大的字段**放在前面

#### 联合索引范围查询

Q1: `select * from t_table where a > 1 and b = 2`，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？
A1：**a**

Q2: `select * from t_table where a >= 1 and b = 2`，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？
A2：**a, b**（a == 1的情况下会用到b）

Q3: `SELECT * FROM t_table WHERE a BETWEEN 2 AND 8 AND b = 2`，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？
A3：**a, b**（a == 1的情况下会用到b）

Q4: `SELECT * FROM t_user WHERE name like 'j%' and age = 22`，联合索引（name, age）哪一个字段用到了联合索引的 B+Tree？ 
A4:  name, age

#### 索引下推优化

MySQL 5.6引入，**可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数**

### 什么时候适用索引

- 字段具有唯一性
- 经常用于`where`查询条件的字段
- 经常用于 `GROUP BY` 和 `ORDER BY` 的字段

### 优化索引的方法

- 前缀索引优化
- 覆盖索引优化
- 主键索引最好是自增的
- 索引最好是NOT NULL

### 为什么MySQL采用B+树作为索引

