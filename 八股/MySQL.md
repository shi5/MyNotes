## MySQL结构

server + 存储引擎

Server：建立连接、分析和执行SQL
存储引擎：存储和读取数据

## select查询语句执行过程

1. 连接器
	- MySQL基于TCP，分为长连接和短链接
2. 查询缓存
	- server层会将之前查询的结果缓存
	- 比较鸡肋，8.0被删除
3. 解析SQL
	2. 解析器
		- 词法分析
		- 语法分析
1. 执行SQL
	1. 预处理器
		- 检查表或字段是否存在（8.0之前是在预处理之前）
		- 将`select *`中的`*`扩展为表上所有列
	2. 优化器：确定SQL查询的语句的执行方案
		- `explain`命令可以用于查看sql的执行方案
	1. 执行器
		- 主键索引查询
		- 全表扫描
		- 索引下推：在二级索引中判断条件

## 表空间结构

段-区-页-行

段：
- 索引段
- 数据段
- 回滚段

区：为了保证连续io

页：数据库的数据**按「页」为单位来读写的**
- 页与页之间双向链表连接
- 页内记录按照主键顺序组成单向链表
- 页目录起索引作用，页内记录会分组，页目录存储每个分组的最后一项记录的地址
> InnoDB 里的 B+ 树中的**每个节点都是一个数据页**

行：记录按行存放

### 行格式

4种行格式：
- Redundant（不常用）：不紧凑
- Compact（5.1）：紧凑行格式
- Dynamic（5.7）：基于Compact改进
- Compressed：基于Compact改进

#### Compact行格式

![[Pasted image 20240423205516.png]]

三个额外信息：
- 变长字段长度列表：**逆序**，**非必须**，存储列中变长字段的长度
- NULL值列表：**逆序**，**非必须**，存储列中字段是否为NULL，通过二进制位（1为NULL），NULL值列表必须用整数个字节来表示，不足高位补零
- 记录头信息：包含很多，如delete_mask、next_record、record_type
> 

三个隐藏列：
- row_id：**非必需**，当表中没有主键和唯一约束的列时，InnoDB 就会为记录添加 row_id 隐藏字段
- trx_id：操作该数据的事务id，当**一个事务对某条聚簇索引记录进行改动时**，会将该事务的事务id记录到trx_id隐藏列中
- roll_pointer：记录上一个版本的指针，每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，这样可以找到修改前的记录

#### varchar中的n最大取值为多少

**MySQL 规定除了 TEXT、BLOBs 这种大对象类型之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过 65535 个字节**。

因此需要根据实际情况分析，要保证 其他所有字段的长度 + 变长字段的长度 不超过 2^16(=65535)

#### 行溢出处理方式

主要发生在存储TEXT、BLOB这些大对象的时候

Compact：发生行溢出时，**多余数据会存到另外的「溢出页」中**，行记录中存储“部分数据+溢出页地址”
![[Pasted image 20240423205816.png]]

Compressed 和 Dynamic：**溢出数据全部存到「溢出页」**，行记录中存储“溢出页地址”

> 溢出页地址20字节

## 索引

### 索引分类

- 按「数据结构」分类：**B+tree索引、Hash索引、Full-text索引**。
- 按「物理存储」分类：**聚簇索引（主键索引）、二级索引（辅助索引）**。
- 按「字段特性」分类：**主键索引、唯一索引、普通索引、前缀索引**。
- 按「字段个数」分类：**单列索引、联合索引**。

### 索引选择

- 有主键，逐渐作为聚簇索引的索引键（key
- 没有主键，选取第一个不包含NULL的唯一列作为聚簇索引的索引键（key
- 上述都没有，InnoDB自动生成一个隐式自增 id 列作为聚簇索引的索引键（key

其他索引都属于辅助索引，也被称为二级索引或非聚簇索引

默认使用B+树作为索引的数据结构

### 联合索引

联合索引：多个字段组合成一个索引

- 存在先后顺序：(a,b,c)和(b,a,c)不一样
- 最左匹配原则

> 建立联合索引的时候要把**区分度大的字段**放在前面

#### 联合索引范围查询

Q1: `select * from t_table where a > 1 and b = 2`，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？
A1：**a**

Q2: `select * from t_table where a >= 1 and b = 2`，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？
A2：**a, b**（a == 1的情况下会用到b）

Q3: `SELECT * FROM t_table WHERE a BETWEEN 2 AND 8 AND b = 2`，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？
A3：**a, b**（a == 1的情况下会用到b）

Q4: `SELECT * FROM t_user WHERE name like 'j%' and age = 22`，联合索引（name, age）哪一个字段用到了联合索引的 B+Tree？ 
A4:  name, age

#### 索引下推优化

MySQL 5.6引入，**可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数**

### 什么时候适用索引

- 字段具有唯一性
- 经常用于`where`查询条件的字段
- 经常用于 `GROUP BY` 和 `ORDER BY` 的字段

### 优化索引的方法

- 前缀索引优化
- 覆盖索引优化
- 主键索引最好是自增的
- 索引最好是NOT NULL

### 为什么MySQL采用B+树作为索引

相对于二叉树和平衡二叉树：
- 二叉树和平衡二叉树随节点增多，树高度变大

相对于B树：
- B+树非叶子节点能存更多索引，树更加矮胖
- B+树范围查询更好
- B+ 树的插入和删除效率更高（B+树存在很多冗余节点）

### 索引失效的原因

- 对索引使用左或左右范围查询
- 对索引使用函数
- 对索引使用表达式
- 对索引进行隐式类型转换
- 联合索引不满足最左匹配
- where子句使用or

## 事务

### 事务特性

ACID
- 原子性： undo log（回滚日志） 来保证
- 一致性：持久性+原子性+隔离性来保证
- 隔离性： MVCC（多版本并发控制） 或锁机制来保证
- 持久性： redo log （重做日志）来保证的

### 并发事务存在的问题

- 脏读：读到其他事务未提交的数据；
- 不可重复读：前后读取的数据不一致；
- 幻读：前后读取的记录数量不一致。

严重性排序：脏读>不可重复读>幻读

### 事务的隔离级别

- 读未提交
- 读提交
- 可重复读：**MySQL InnoDB 引擎的默认隔离级别**
- 串行化

不同隔离级别下可能的问题：
![[Pasted image 20240424102831.png]]

#### 怎么实现的

- 读未提交：直接读最新数据就行
- 串行化：加读写锁来避免并行访问
- **读提交** 和 **可重复读**：通过`Read View`实现的，Read View相当于一个数据快照，二者的区别在于创建Read View的时机不同，**读提交**会在**每个语句执行前**都会重新生成一个Read View，而**可重复读**是在**启动事务时**生成一个Read View，然后整个事务期间都在用这个Read View

MySQL的可重复读可以很大程度上避免幻读：
- 针对快照读（普通select），采用MVCC方式解决了幻读
- 针对当前读（select ... for update 等语句），**通过 next-key lock（记录锁+间隙锁）方式解决了幻读**

不能完全避免：
- 对于快照读， MVCC 并不能完全避免幻读现象。因为当事务 A 更新了一条事务 B 插入的记录，那么事务 A 前后两次查询的记录条目就不一样了，所以就发生幻读。
- 对于当前读，如果事务开启后，并没有执行当前读，而是先快照读，然后这期间如果其他事务插入了一条记录，那么事务后续使用当前读进行查询的时候，就会发现两次查询的记录条目就不一样了，所以就发生幻读

#### Read View

Read View会维护四个字段：
- creator_trx_id：创建该Read View事务的事务id
- m_ids：创建Read View时，当前数据库中**活跃事务**的事务id列表（活跃事务是指，启动了但还没提交的事务
- min_trx_id：m_ids中的最小值
- max_trx_id：创建该Read View事务时当前数据库应该给下一个事务的id，也就是**全局事务中最大的事务 id 值 + 1**

此时，需要用到行记录中的两个隐藏列：**trx_id** 和 **roll_pointer**(见[[MySQL#Compact行格式]])

这样根据Read View和tri_id就可以确定哪些记录时可见的，不可见则通过**roll_pointer**不断回溯：
- tri_id < min_trx_id： 可见
- tri_id >= max_trx_id：不可见
- min_trx_id <= tri_id < max_trx_id： 
	- tri_id 在 m_ids中：不可见
	- tri_id 不在 m_ids中：可见

## 锁

### MySQL 有哪些锁？

在 MySQL 里，根据加锁的范围，可以分为**全局锁、表级锁和行锁**三类。

![[Pasted image 20240424105039.png]]

### 全局锁 

对整个数据库加锁

主要应用于做**全库逻辑备份**

#### 如何避免使用全局锁备份时带来的影响

可以在**可重复读的隔离级别**下进行，在备份数据库之前先开启事务，会先创建 Read View，然后整个事务执行期间都在用这个 Read View

### 表级锁

- 表锁：读写锁，表锁除了会限制别的线程的读写外，也会限制本线程接下来的读写操作
- 元数据锁（MDL）：为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。
	- 对一张表进行 CRUD 操作时，加的是 **MDL 读锁**；
	- 对一张表做结构变更操作的时候，加的是 **MDL 写锁**；
	- 事务提交后才会释放
- 意向锁：在对**某些记录**添加「共享锁」或「独占锁」之前，需要先在表级别加上一个「意向共享锁」或「意向独占锁」，**意向锁的目的是为了快速判断表里是否有记录被加锁**
- AUTO-INC 锁：**在插入数据时，会加一个表级别的 AUTO-INC 锁**
	- **在执行完插入语句后就会立即释放**

### 行级锁

- Record Lock，记录锁，有 S 锁和 X 锁之分，只把一条记录锁上；（左闭右闭）
- Gap Lock，间隙锁，锁定一个范围，但是不包含记录本身；（左开右开）
	- 只在**可重复读**隔离级别下，目的是为了解决幻读
	- 间隙锁不存在互斥关系
- Next-Key Lock：临键锁，Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。（左开右闭）

插入意向锁：一种特殊的间隙锁，属于行级别锁，**锁住一个点**
- 一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁，如果有的话，插入操作就会发生**阻塞**，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻），在此期间会生成一个**插入意向锁**，表明有事务想在某个区间插入新记录，但是现在处于等待状态。（等待不代表获取到锁了，只有正常状态才是获取到锁）




### MySQL如何加锁

**加锁的对象是索引，加锁的基本单位是 next-key lock**

**在能使用记录锁或者间隙锁就能避免幻读现象的场景下， next-key lock 就会退化成记录锁或间隙锁**。

### MySQL日志

- **undo log（回滚日志）**：是 Innodb 存储引擎层生成的日志，实现了事务中的**原子性**，主要**用于事务回滚和 MVCC**。
- **redo log（重做日志）**：是 Innodb 存储引擎层生成的日志，实现了事务中的**持久性**，主要**用于掉电等故障恢复**；
	- 循环写，两个redo log文件交替写
- **binlog （归档日志）**：是 Server 层生成的日志，主要**用于数据备份和主从复制**；
	- binlog 文件是记录了所有数据库表结构变更和表数据修改的日志，不会记录查询类的操作
	- 全量写

>  redo log 可以在事务没提交之前持久化到磁盘，但是 binlog 必须在事务提交之后，才可以持久化到磁盘。

#### redo log 要写到磁盘，数据也要写磁盘，为什么要多此一举？

写入 redo log 的方式使用了追加操作， 所以磁盘操作是**顺序写**
而写入数据需要先找到写入位置，然后才写到磁盘，所以磁盘操作是**随机写**。

#### 主从复制是怎么实现的

MySQL 的主从复制依赖于 binlog 

这个过程是异步的

#### 两阶段提交

提交过程：
1. 写入redo log 
2. 写入binlog
3. 提交

内部事务管理这个过程，1为prepare过程，2和3为commit过程

**两阶段提交是以 binlog 写成功为事务提交成功的标识**

## Buffer Pool

三个链表来管理buffer pool的缓冲页
- Free List （空闲页链表），管理空闲页；
- Flush List （脏页链表），管理脏页；
- LRU List，管理脏页+干净页，将最近且经常查询的数据缓存在其中，而不常查询的数据就淘汰出去。

LRU又被分为两个部分：**young 和 old 两个区域**
- 加入缓冲池的页，优先插入 old 区域；页被访问时，才进入 young 区域，目的是为了解决预读失效的问题。
- 当「页被访问」且「 old 区域停留时间超过 `innodb_old_blocks_time` 阈值（默认为1秒）」时，才会将页插入到 young 区域，否则还是插入到 old 区域，目的是为了解决批量数据访问，大量热数据淘汰的问题