## 创建型模式

### 工厂方法模式

工厂方法是指定义工厂接口和产品接口，但如何创建实际工厂和实际产品被推迟到子类实现，从而使调用方只和抽象工厂与抽象产品打交道

将不同类型的类抽象出来一个工厂类，对这些类的创建不直接使用new，而是通过工厂类的方法返回一个类对象。

即 将对象的创建权交给了工厂，工厂对对象的创建可以自定义化（如添加缓存）

>工厂模式本身是为了屏蔽构建对象的细节，以实现面向接口的目的，以达到无感知切换产品的目的

建议使用`静态工厂方法（简单工厂方法）`，类似`Integer.valueOf()`

### 抽象工厂方法

抽象工厂模式是为了让创建工厂和一组产品与使用相分离，并可以随时切换到另一个工厂以及另一组产品；

将同类型的不同事物类交由同一个工厂来创建：

![[Pasted image 20240621160708.png]]

如上：根据不同的艺术风格构建不同的工厂，同一工厂返回的椅子、沙发、咖啡桌是同一风格

- `简单工厂`使用静态方法，通过`逻辑判断`的方式返回产品
- `工厂方法`抽象出工厂接口，不同产品由不同工厂类生产，不同工厂类由`工厂接口统一调用`
- `抽象工厂`中的每个不同工厂类生产统一系列的多种产品，不同工厂类由`工厂接口统一调用`

### 生成器（Builder）模式

Builder模式是为了创建一个复杂的对象，需要多个步骤完成创建，或者需要多个零件组装的场景，且创建过程中可以灵活调用不同的步骤或组件。

类似于StringBuilder，不断地append()，最后toString()(可以理解为build()，返回产品)

与new出产品再通过setter赋值不同，建造者模式会直接返回一个new的产品（某些类变量不一定有setter）
因此建造者模式通常用于构建不可变对象，一旦对象创建完毕，其状态不能改变，并确保对象的一致性。且扩展性较好，增加新属性只需要在建造者中添加相应的 setter 方法。

### 原型模式

> 原型模式，即Prototype，是指创建新对象的时候，根据现有的一个原型来创建。

利用一个对象创建一个新的对象

### 单例模式

单例模式（Singleton）的目的是为了保证在一个进程中，某个类有且仅有一个实例。

实现方法：
1. 双重判断锁
2. 静态内部类
3. enum类
4. 饿汉模式

## 结构性模式

### 适配器模式

> 适配器模式是Adapter，也称Wrapper，将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

可以理解为“转接头”

```Java
public BAdapter implements B {
    private A a;
    public BAdapter(A a) {
        this.a = a;
    }
    public void b() {
        a.a();
    }
}
```

### 桥接模式

> 将抽象部分与它的实现部分分离，使它们都可以独立地变化。

有一点类似与组合（非组合模式）的感觉
桥接模式常用于需要`多个维度变化`的场景，例如：
- 图形和颜色的组合。
- 数据库和数据访问方式的组合。

思想：不要过度使用继承，而是优先拆分某些部件

### 组合模式

> 将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。

【和面向对象中的`组合`不同】

类似文件夹和文件，二者之间存在一种层级结构，适合使用组合模式处理

组合模式提供了两种共享公共接口的基本元素类型： 简单叶节点（文件）和复杂容器（文件夹）。依赖递归组合来组织无限数量的对象

### 装饰器模式

> 动态地给一个对象添加一些额外的职责。就增加功能来说，相比生成子类更为灵活。

装饰器模式将核心功能和附加功能分开了，利用装饰器模式可以在运行期动态地给核心功能增加任意个附加功能。

```ascii
		     ┌───────────┐
             │ Component │
             └───────────┘
                   ▲
      ┌────────────┼─────────────────┐
      │            │                 │
┌───────────┐┌───────────┐     ┌───────────┐
│ComponentA ││ComponentB │...  │ Decorator │
└───────────┘└───────────┘     └───────────┘
                                     ▲
                              ┌──────┴──────┐
                              │             │
                        ┌───────────┐ ┌───────────┐
                        │DecoratorA │ │DecoratorB │...
                        └───────────┘ └───────────┘
```

可以理解为一层一层套娃

### 外观模式

>为子系统中的一组接口提供一个一致的界面。Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

外观（Facade）模式类似于一个中介，对复杂系统进行封装，将业务抽象成接口暴露给调用方

比如：网络三层架构中，控制层就是外观模式的体现

### 享元模式

>运用共享技术有效地支持大量细粒度的对象。

享元（Flyweight）的核心思想很简单：如果一个对象实例一经创建就不可变，那么反复创建相同的实例就没有必要，直接向调用方返回一个共享的实例就行，这样即节省内存，又可以减少创建对象的过程，提高运行速度。

类似于包装类Integer等不变类使用了缓存机制，就是享元模式的体现

### 代理模式

> 为其他对象提供一种代理以控制对这个对象的访问。

## 行为模式

### 责任链模式

> 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。

按顺序交给下一个处理器处理

```ascii
	 ┌─────────┐
     │ Request │
     └─────────┘
          │
┌ ─ ─ ─ ─ ┼ ─ ─ ─ ─ ┐
          ▼
│  ┌─────────────┐  │
   │ ProcessorA  │
│  └─────────────┘  │
          │
│         ▼         │
   ┌─────────────┐
│  │ ProcessorB  │  │
   └─────────────┘
│         │         │
          ▼
│  ┌─────────────┐  │
   │ ProcessorC  │
│  └─────────────┘  │
          │
└ ─ ─ ─ ─ ┼ ─ ─ ─ ─ ┘
          │
          ▼
```

责任链模式本身很容易理解，需要注意的是，`Handler`添加的顺序很重要，如果顺序不对，处理的结果可能就不是符合要求的。

有些责任链由责任链对象调用Handler，有些由上一个Handler调用下一个Handler，还有一些每个Handler都可以处理Request，如拦截器（Interceptor）和过滤器（Filter）

### 命令模式

>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。

如编辑器支持添加、删除、复制、粘贴等命令，使这些命令都独立地实现`Command`接口，从而支持撤销重做等操作。

命令模式的设计思想是把命令的创建和执行分离，使得调用者无需关心具体的执行过程。

### 解释器模式

> 给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。

如正则表达式解释器

### 迭代器模式

> 提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。

例如Java中的`Iterator`

### 中介模式

> 用一个中介对象来封装一系列的对象交互。中介者使各个对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。

中介（Mediator）模式又称调停者模式，通过引入一个中介对象，把多边关系变成多个双边关系，从而简化系统组件的交互耦合度。
主要目标是**消除一系列系统组件之间的相互依赖**。

例如：复选框
![[Pasted image 20240709102049.png]]

MVC可以看作Mediator模式的扩展

### 备忘录模式

> 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。

备忘录模式（Memento），主要用于捕获一个对象的内部状态，以便在将来的某个时候恢复此状态。

Java的序列化就可以看成使备忘录模式

### 观察者模式

> 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

观察者模式（Observer）又称发布-订阅模式（Publish-Subscribe：Pub/Sub）。

### 状态模式

> 允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。

状态模式的设计思想是把不同状态的逻辑分离到不同的状态类中，从而使得增加新状态更容易；

如QQ的不同状态(在线、离线、忙碌)下的行为不一样

### [[策略模式]] 

> 定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。

如Java的`Arrays.sort`就采用了策略模式

### 模板方法模式

> 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

模板方法的核心思想是：父类定义骨架，子类实现某些细节。

为了防止子类重写父类的骨架方法，可以在父类中对骨架方法使用`final`。对于需要子类实现的抽象方法，一般声明为`protected`，使得这些方法对外部客户端不可见。

### 访问者模式

> 表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。


