## 创建型模式

### 工厂方法模式

工厂方法是指定义工厂接口和产品接口，但如何创建实际工厂和实际产品被推迟到子类实现，从而使调用方只和抽象工厂与抽象产品打交道

将不同类型的类抽象出来一个工厂类，对这些类的创建不直接使用new，而是通过工厂类的方法返回一个类对象。

即 将对象的创建权交给了工厂，工厂对对象的创建可以自定义化（如添加缓存）

>工厂模式本身是为了屏蔽构建对象的细节，以实现面向接口的目的，以达到无感知切换产品的目的

建议使用`静态工厂方法（简单工厂方法）`，类似`Integer.valueOf()`

### 抽象工厂方法

抽象工厂模式是为了让创建工厂和一组产品与使用相分离，并可以随时切换到另一个工厂以及另一组产品；

将同类型的不同事物类交由同一个工厂来创建：

![[Pasted image 20240621160708.png]]

如上：根据不同的艺术风格构建不同的工厂，同一工厂返回的椅子、沙发、咖啡桌是同一风格

- `简单工厂`使用静态方法，通过`逻辑判断`的方式返回产品
- `工厂方法`抽象出工厂接口，不同产品由不同工厂类生产，不同工厂类由`工厂接口统一调用`
- `抽象工厂`中的每个不同工厂类生产统一系列的多种产品，不同工厂类由`工厂接口统一调用`

### 生成器（Builder）模式

Builder模式是为了创建一个复杂的对象，需要多个步骤完成创建，或者需要多个零件组装的场景，且创建过程中可以灵活调用不同的步骤或组件。

类似于StringBuilder，不断地append()，最后toString()(可以理解为build()，返回产品)

与new出产品再通过setter赋值不同，建造者模式会直接返回一个new的产品（某些类变量不一定有setter）
因此建造者模式通常用于构建不可变对象，一旦对象创建完毕，其状态不能改变，并确保对象的一致性。且扩展性较好，增加新属性只需要在建造者中添加相应的 setter 方法。

### 原型模式

> 原型模式，即Prototype，是指创建新对象的时候，根据现有的一个原型来创建。

利用一个对象创建一个新的对象

### 单例模式

单例模式（Singleton）的目的是为了保证在一个进程中，某个类有且仅有一个实例。

实现方法：
1. 双重判断锁
2. 静态内部类
3. enum类
4. 饿汉模式

## 结构性模式

### 适配器模式

> 适配器模式是Adapter，也称Wrapper，将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

可以理解为“转接头”

```Java
public BAdapter implements B {
    private A a;
    public BAdapter(A a) {
        this.a = a;
    }
    public void b() {
        a.a();
    }
}
```

### 桥接模式

> 将抽象部分与它的实现部分分离，使它们都可以独立地变化。

有一点类似与组合（非组合模式）的感觉
桥接模式常用于需要`多个维度变化`的场景，例如：
- 图形和颜色的组合。
- 数据库和数据访问方式的组合。

思想：不要过度使用继承，而是优先拆分某些部件

### 组合模式

> 将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。

【和面向对象中的`组合`不同】

类似文件夹和文件，二者之间存在一种层级结构，适合使用组合模式处理

组合模式提供了两种共享公共接口的基本元素类型： 简单叶节点（文件）和复杂容器（文件夹）。依赖递归组合来组织无限数量的对象

### 装饰器模式

> 动态地给一个对象添加一些额外的职责。就增加功能来说，相比生成子类更为灵活。

装饰器模式将核心功能和附加功能分开了，利用装饰器模式可以在运行期动态地给核心功能增加任意个附加功能。

```ascii
		     ┌───────────┐
             │ Component │
             └───────────┘
                   ▲
      ┌────────────┼─────────────────┐
      │            │                 │
┌───────────┐┌───────────┐     ┌───────────┐
│ComponentA ││ComponentB │...  │ Decorator │
└───────────┘└───────────┘     └───────────┘
                                     ▲
                              ┌──────┴──────┐
                              │             │
                        ┌───────────┐ ┌───────────┐
                        │DecoratorA │ │DecoratorB │...
                        └───────────┘ └───────────┘
```

可以理解为一层一层套娃

### 外观模式

>为子系统中的一组接口提供一个一致的界面。Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

外观（Facade）模式类似于一个中介，对复杂系统进行封装，将业务抽象成接口暴露给调用方

比如：网络三层架构中，控制层就是外观模式的体现

### 享元模式

>运用共享技术有效地支持大量细粒度的对象。

享元（Flyweight）的核心思想很简单：如果一个对象实例一经创建就不可变，那么反复创建相同的实例就没有必要，直接向调用方返回一个共享的实例就行，这样即节省内存，又可以减少创建对象的过程，提高运行速度。

类似于包装类Integer等不变类使用了缓存机制，就是享元模式的体现

### 代理模式

> 为其他对象提供一种代理以控制对这个对象的访问。

## 行为模式

### 责任链模式

> 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。

按顺序交给下一个处理器处理

```ascii
	 ┌─────────┐
     │ Request │
     └─────────┘
          │
┌ ─ ─ ─ ─ ┼ ─ ─ ─ ─ ┐
          ▼
│  ┌─────────────┐  │
   │ ProcessorA  │
│  └─────────────┘  │
          │
│         ▼         │
   ┌─────────────┐
│  │ ProcessorB  │  │
   └─────────────┘
│         │         │
          ▼
│  ┌─────────────┐  │
   │ ProcessorC  │
│  └─────────────┘  │
          │
└ ─ ─ ─ ─ ┼ ─ ─ ─ ─ ┘
          │
          ▼
```

责任链模式本身很容易理解，需要注意的是，`Handler`添加的顺序很重要，如果顺序不对，处理的结果可能就不是符合要求的。

有些责任链由责任链对象调用Handler，有些由上一个Handler调用下一个Handler，还有一些每个Handler都可以处理Request，如拦截器（Interceptor）和过滤器（Filter）

### 命令模式

>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。