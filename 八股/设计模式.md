## 创建型模式

### 工厂方法模式

工厂方法是指定义工厂接口和产品接口，但如何创建实际工厂和实际产品被推迟到子类实现，从而使调用方只和抽象工厂与抽象产品打交道

将不同类型的类抽象出来一个工厂类，对这些类的创建不直接使用new，而是通过工厂类的方法返回一个类对象。

即 将对象的创建权交给了工厂，工厂对对象的创建可以自定义化（如添加缓存）

>工厂模式本身是为了屏蔽构建对象的细节，以实现面向接口的目的，以达到无感知切换产品的目的

建议使用`静态工厂方法（简单工厂方法）`，类似`Integer.valueOf()`

### 抽象工厂方法

抽象工厂模式是为了让创建工厂和一组产品与使用相分离，并可以随时切换到另一个工厂以及另一组产品；

将同类型的不同事物类交由同一个工厂来创建：

![[Pasted image 20240621160708.png]]

如上：根据不同的艺术风格构建不同的工厂，同一工厂返回的椅子、沙发、咖啡桌是同一风格

- `简单工厂`使用静态方法，通过`逻辑判断`的方式返回产品
- `工厂方法`抽象出工厂接口，不同产品由不同工厂类生产，不同工厂类由`工厂接口统一调用`
- `抽象工厂`中的每个不同工厂类生产统一系列的多种产品，不同工厂类由`工厂接口统一调用`

### 生成器（Builder）模式

Builder模式是为了创建一个复杂的对象，需要多个步骤完成创建，或者需要多个零件组装的场景，且创建过程中可以灵活调用不同的步骤或组件。

类似于StringBuilder，不断地append()，最后toString()(可以理解为build()，返回产品)

与new出产品再通过setter赋值不同，建造者模式会直接返回一个new的产品（某些类变量不一定有setter）
因此建造者模式通常用于构建不可变对象，一旦对象创建完毕，其状态不能改变，并确保对象的一致性。且扩展性较好，增加新属性只需要在建造者中添加相应的 setter 方法。

### 原型模式

原型模式，即Prototype，是指创建新对象的时候，根据现有的一个原型来创建。

### 单例模式

单例模式（Singleton）的目的是为了保证在一个进程中，某个类有且仅有一个实例。

实现方法：
1. 双重判断锁
2. 静态内部类
3. enum类
4. 饿汉模式

## 结构性模式

### 适配器模式

适配器模式是Adapter，也称Wrapper，将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

可以理解为“转接头”

```Java
public BAdapter implements B {
    private A a;
    public BAdapter(A a) {
        this.a = a;
    }
    public void b() {
        a.a();
    }
}
```

### 桥接模式

将抽象部分与它的实现部分分离，使它们都可以独立地变化。