## JDK、JRE和JVM的关系
- JDK（Java Development Kit），它是功能齐全的 Java SDK，是提供给开发者使用，能够创建和编译 Java 程序的开发套件。它包含了 JRE，同时还包含了编译 java 源码的编译器 javac 以及一些其他工具比如 javadoc（文档注释工具）、jdb（调试器）、jconsole（基于 JMX 的可视化监控⼯具）、javap（反编译工具）等等。
- JRE（Java Runtime Environment） 是 Java `运行时`环境。它是运行已编译 Java 程序所需的所有内容的集合，主要包括 Java 虚拟机（JVM）、Java 基础类库（Class Library）。

![[Pasted image 20240314122731.png]]

## JAVA是编译与解释并存的语言

Java 语言既具有编译型语言的特征，也具有解释型语言的特征。因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（`.class` 文件），这种字节码必须由 Java 解释器来解释执行。

我们需要格外注意的是 `.class->机器码` 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 **JIT（Just in Time Compilation）** 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。

![[Pasted image 20240314123221.png]]

## `final` 关键字

`final` 关键字修饰的类不能被继承，修饰的方法不能被重写，修饰的变量是基本数据类型则值不能改变
## 变量初始值

只有成员变量才有默认值，而局部变量必须要赋初值。

使用`new`创建在堆上的数组元素均有默认值

## 浅拷贝、深拷贝和引用拷贝

| 类型   | 拷贝机制                                | 实现方法                                                                                                                            | 补充说明                                                                                                 |
| ---- | ----------------------------------- | ------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------- |
| 引用拷贝 | 将指向对象的`地址`复制                        | 变量名赋值即可                                                                                                                         | 无                                                                                                    |
| 浅拷贝  | 创建一个`新对象`，新对象与原对象不等，但`新对象的属性和老对象相同` | 在需要拷贝的类上实现`Cloneable接口并重写其clone()`方法。                                                                                           | 如果新对象或老对象的属性改变了指向，另一个的属性不会改变                                                                         |
| 深拷贝  | 创建的新对象的`属性内容`和老对象相同，但是`完全独立`于老对象    | - `重写clone()方法`，要将类中所有自定义引用变量的类也去实现Cloneable接口实现clone()方法。<br>- `序列化`，自定义的类**需要实现Serializable接口**，在需要深拷贝的类中定义一个函数返回该类对象，之后调用该函数 | 序列化后：将二进制字节流内容写到一个媒介（文本或字节数组），然后是从这个媒介读取数据，原对象写入这个媒介后拷贝给clone对象，原对象的修改不会影响clone对象，因为clone对象是从这个媒介读取。 |
|      |                                     |                                                                                                                                 |                                                                                                      |
![[Pasted image 20240314171711.png]]

![[Pasted image 20240314171722.png]]

![[Pasted image 20240314171732.png]]

## Native method

- 本地方法：java代码里面写的`native`方法，它没有方法体。是为了调用`C/C++`代码而写的。在JNI程序里面使用。
- 使用原因：
	- JVM的实现，为了与操作系统底层进行交互，就使用了本地方法
	- JVM自己的代码，有一部分使用C实现的，这些代码的使用也需要使用本地方法

## 为什么重写 equals() 时必须重写 hashCode() 方法

因为两个相等的对象的 `hashCode` 值必须是相等。也就是说如果 `equals` 方法判断两个对象是相等的，那这两个对象的 `hashCode` 值也要相等。

如果重写 `equals()` 时没有重写 `hashCode()` 方法的话就可能会导致 `equals` 方法判断是相等的两个对象，`hashCode` 值却不相等。

## String类型

### String类型为何不可变

- 保存字符串的数组被 `final` 修饰且为私有的，并且`String` 类没有提供/暴露修改这个字符串的方法。
- `String` 类被 `final` 修饰导致其不能被继承，进而避免了子类破坏 `String` 不可变。

> 在 Java 9 之后，`String`、`StringBuilder` 与 `StringBuffer` 的实现改用 `byte` 数组存储字符串。

### String通过 `+`拼接原理

字符串对象通过“+”的字符串拼接方式，实际上是通过 `StringBuilder` 调用 `append()` 方法实现的，拼接完成之后调用 `toString()` 得到一个 `String` 对象 。

### 字符串常量池

**字符串常量池** 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。

## 常量折叠

对于编译期可以确定值的字符串，也就是常量字符串 ，jvm 会将其存入字符串常量池。并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化。

常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中，这是 Javac 编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行)。

## SPI

SPI 即 Service Provider Interface ，字面意思就是：“服务提供者的接口”，可以理解为：专门提供给服务提供者或者扩展框架功能的开发者去使用的一个接口。

![[Pasted image 20240314200618.png]]

## 序列化与但序列化

- **序列化**：将数据结构或对象转换成二进制字节流的过程
- **反序列化**：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程

常见应用场景：网络传输、存储到文件、存储到数据库、存储到内存

### 不进行序列化

对于不想进行序列化的变量，使用 `transient` 关键字修饰。

`transient` 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 `transient` 修饰的变量值不会被持久化和恢复。

`static`变量不会被序列化，因为其不属于任何对象（Object）

## IO流

Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。

- `InputStream`/`Reader`: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。
- `OutputStream`/`Writer`: 所有输出流的基类，前者是字节输出流，后者是字符输出流。

### I/O 流为什么要分为字节流和字符流呢?

问题本质想问：**不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？**

个人认为主要有两点原因：

- 字符流是由 Java 虚拟机将字节转换得到的，这个过程还算是比较耗时；
- 如果我们不知道编码类型的话，使用字节流的过程中很容易出现乱码问题。