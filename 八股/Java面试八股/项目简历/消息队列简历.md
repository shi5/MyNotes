![[Pasted image 20240728143325.png]]

**项目介绍**：

在这个项目中，我设计并开发了一个简易的消息队列系统，主要目的是为了学习理解和实践消息队列中间件的关键概念和技术。该系统采用了Netty框架，基于发布-订阅模型构建，支持多生产者和多消费者的应用场景。
- **发布-订阅模型**: 系统允许消息生产者向不同的主题发布消息，同时支持消费者订阅感兴趣的主题，以接收相应的消息内容。这种模型有效地实现了消息的广播和分发功能。
    
- **多队列与多消费者组**: 每个主题可以配置多个队列，且消费者组中支持多消费者。这样的设计使得系统能够处理高并发和大规模的消息流量，确保了消息处理的效率和灵活性。
    
- **多Broker部署**: 为了提高系统的可用性和扩展性，项目支持多Broker部署，分散了消息负载，增强了系统的容灾能力。
    
- **消息持久化**: 消息系统通过文件系统实现了消息的持久化存储，确保消息在系统故障时不会丢失。持久化机制采用了零拷贝技术（`mmap`），大幅提升了磁盘文件操作的性能。
    
- **负载均衡和重试机制**: 系统内置了消息发送与消费的负载均衡功能，支持多种策略（如轮询、随机、加权轮询等），以优化资源使用。与此同时，为了保证消息的可靠传递，系统还实现了消息重试机制，有效提高了消息的传递成功率。

通过这个项目，我深刻理解了消息队列系统的核心技术，包括消息的分发与路由、持久化、负载均衡等。

## 发布订阅模式

主流传输模型：队列模型（点对点模型）和主题模型（发布订阅模型）

### 点对点模型

![[Pasted image 20240728164840.png]]

- 生产者向队列发送消息，消费者从队列取消息
- 消费者和生产者无身份标识
- 消费匿名：消息上下游沟通的唯一的身份就是队列，下游消费者从队列获取消息无法申明独立身份。
- 一对一通信：每条消息只会被唯一消费者处理

### 发布-订阅模型 

![[Pasted image 20240728165045.png]]

- 生产者向队主题发送消息，消费者从主题取消息 
- 生产者组和消费者组，同一组生产或消费同一类消息
- 消费独立：不同消费者组之间不会相互影响
- 一对多通信：同一个主题内的消息可以被多个消费者组处理

### 对比

点对点模型更为简单，而发布订阅模型的扩展性更高

## Netty

### Netty相关问题

[宝贝儿！你要的Netty常见面试题总结，Guide搞来了！-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1648319)

### 自定义协议的格式

- 固定长度
- 指定分隔符（目前采用）
- 自定义格式报文

将对象转换为Json字符串进行传输并使用固定分隔符来切分报文

## 持久化相关

[[RocketMQ#消息持久化]]

### 介绍

类似于Rocketmq的持久化，所有消息统一存储在CommitLog中，确保消息发送时按顺序写文件，尽最大的能力确保消息发送的高性能与高吞吐量，队列采用ConsumeQueue消息消费队列文件，存入CommitLog的索引，是逻辑队列的形式。

### 为什么要采用文件系统持久化

目前消息队列持久化的方案有两种：文件系统和数据库；文件系统相对于数据库少了网络io的开销，且不需要第三方依赖，采用数据库则方便简单，数据库提供更复杂的查询和事务处理功能，但这些功能可能带来额外的开销。

目前主流的消息队列中间件都是采用基于文件系统的持久化方式

![[QQ_1722225792949.png]]

### 零拷贝技术
read + write：![[Pasted image 20240729113420.png]]

mmap + write：![[Pasted image 20240729113431.png]]

sendfile：![[Pasted image 20240729113440.png]]
![[Pasted image 20240729114409.png]]

### 为什么不采用sendfile

- mmap在发送小数据量时比sendfile性能更好，因为mmap可以使用NIO，而sendfile只能使用BIO

## 个人感悟

### 这个项目的难点和亮点在哪？

### 这个项目给你带来了哪些收获，有什么感悟?

### 项目中存在哪些可优化的点（缺陷）?

### 和RocketMQ相比，项目还有哪些提升？