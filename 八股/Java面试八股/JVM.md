## Java内存区域 #重要 

### 运行时数据区域

![[Pasted image 20240327222232.png]]

![[Pasted image 20240327222240.png]]

**线程私有的：**
- 程序计数器
- 虚拟机栈
- 本地方法栈

**线程共享的：**
- 堆
- 方法区
- 直接内存 (非运行时数据区的一部分)

#### 虚拟机栈

栈帧内容：
- 局部变量表
- 操作数栈：主要作为方法调用的中转站使用，用于存放方法执行过程中产生的中间计算结果。另外，计算过程中产生的临时变量也会放在操作数栈中。
- 动态链接：动态链接的作用就是为了将符号引用转换为调用方法的直接引用，这个过程也被称为 **动态连接** 。
- 方法返回地址

#### 堆

**唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。**

#### 方法区

当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的 **类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据**。

永久代以及元空间是 HotSpot 虚拟机对虚拟机规范中方法区的两种`实现`方式。

常量池表会在类加载后存放到方法区的运行时常量池中。
**字符串常量池** 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。

### 本地内存& 直接内存 & 元空间

![[Pasted image 20240327213123.png]]

- 虚拟机内存：JVM直接管理的内存区域成为
- 本地内存：JVM利用到但没受没有直接管理的内存
	- 直接内存：在Java堆外的、直接向系统申请的内存区域。
	- 元空间

### 虚拟机栈

![[Pasted image 20240327213208.png]]

## HotSpot 虚拟机对象

### 对象的创建（最好能默写） #重要

1. 类加载检查：检查是否加载过、解析和初始化过
2. 分配内存：**分配方式**有 **“指针碰撞”** 和 **“空闲列表”** 两种，**选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定**。 内存分配并发问题
3. 初始化零值：将分配到的内存空间都初始化为零值（不包括对象头）
4. 设置对象头：**虚拟机要对对象进行必要的设置**，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。
5. 执行init方法

### 对象的访问定位

- 句柄
- 直接指针

## JVM垃圾回收 #重要 

### Java堆空间的基本结构

Java 堆是垃圾收集器管理的主要区域，因此也被称作 **GC 堆（Garbage Collected Heap）**

在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：

1. 新生代内存(Young Generation)
2. 老生代(Old Generation)
3. 永久代(Permanent Generation)

**JDK 8 版本之后 PermGen(永久) 已被 Metaspace(元空间) 取代，元空间使用的是直接内存** 。

![[Pasted image 20240328162517.png]]

### 内存分配和回收原则

- 对象优先在Eden区分配
- 大对象直接进入老年代：大对象就是需要大量连续内存空间的对象（比如：字符串、数组）
- 长期存活的对象将进入老年代：虚拟机给每个对象一个对象年龄（Age）计数器。
- 主要进行gc的区域
	- 部分收集 (Partial GC)：
		- 新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；
		- 老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；
		- 混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。
	- 整堆收集 (Full GC)：收集整个 Java 堆和方法区。
- 空间分配担保：确保在 Minor GC 之前老年代本身还有容纳新生代所有对象的剩余空间。

### 死亡对象判断方法

#### 引用计数法

给对象中添加一个引用计数器，任何时候计数器为 0 的对象就是不可能再被使用的。

存在问题：**它很难解决对象之间循环引用的问题。**

#### 可达性分析算法

这个算法的基本思想就是通过一系列的称为 **“GC Roots”** 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。

**哪些对象可以作为 GC Roots 呢？**
- 虚拟机栈(栈帧中的局部变量表)中引用的对象
- 本地方法栈(Native 方法)中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 所有被同步锁持有的对象
- JNI（Java Native Interface）引用的对象

**对象可以被回收，就代表一定会被回收吗？**
要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 `finalize` 方法。当对象没有覆盖 `finalize` 方法，或 `finalize` 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。
被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。

#### 引用类型总结

![[Pasted image 20240328164645.png]]

1. 强引用：大部分的引用都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于**必不可少的生活用品**，垃圾回收器绝不会回收它。
2. 软引用：如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。
3. 弱引用：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。
4. 虚引用：虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。**虚引用主要用来跟踪对象被垃圾回收的活动**，虚引用必须和引用队列（ReferenceQueue）联合使用。

> 在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为**软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生**。