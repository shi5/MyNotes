## 消息持久化

- 为什么要采取文件系统存储，而不是数据库
	- 效率上，本地磁盘更快，比数据库少了网络开销（主要）
	- 数据稳定性更高
	- 减少了第三方依赖

- 为什么要采用commitlog + consumerqueue的方式 
	- 可以实现顺序写入与近似顺序读取，磁盘的顺序IO效率很高，磁头几乎不用换道，或者换道的时间很短。（*磁盘与内存相关知识需要补充*）
	- 对于commitlog，所有消息写入都是顺序的，消息读取是随机的，但整体上还是顺序读的，因为是**都是从旧数据到新数据有序的读取。**

- 页缓存的不确定性和mmap的惰性加载（实际使用才真正加载）如何解决
	- **文件预分配**和**文件预热**。

- 为什么要采用mmap而不是sendfile，而Kafka是采用sendfile（*可以继续深入研究*
	- 零拷贝包括两种方式，RocketMQ 使用**mmap+write**，因单个消息是小块数据，小块数据传输的要求效果比 sendfile 方式好
		- mmap支持NIO，sendfile只能BIO传输，那么NIO的特性本身就会对数据块小、请求个数多的传输需求有很好的支持。
	- RocketMQ一个CommitLog会有多个Topic的消息，服务端需要做查找过滤，也就是需要对磁盘文件读取出来的结果做加工再返回，而Kafka一个segment文件是partition级别的，不需要处理直接返回给客户端就行，所以用sendfile会更合适
![[QQ_1720688553261.png]]


## 获取消息方式

Consumer 端的两种消费模式（Push/Pull）都是基于拉模式来获取消息的，而在 Push 模式只是对 pull 模式的一种封装，其**本质实现为消息拉取线程在从服务器拉取到一批消息后，然后提交到消息消费线程池后，又“马不停蹄”的继续向服务器再次尝试拉取消息**。如果未拉取到消息，则延迟一下又继续拉取。

因此，有必要在 Consumer 端来做负载均衡

消息消费队列在同一消费组不同消费者之间的负载均衡，其核心设计理念是**在一个消息消费队列在同一时间只允许被同一消费组内的一个消费者消费，一个消息消费者能同时消费多个消息队列。**

## 消息发送

RocketMQ消息队列中支持通信的方式主要有同步(sync)、异步(async)、单向(oneway) 三种