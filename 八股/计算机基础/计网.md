## 键入网址到网页显示

![[Pasted image 20240418142734.png]]

1. 浏览器解析URL并生成HTTP消息
2. 查询服务器域名对应的 IP 地址
3. 把 HTTP 的传输工作交给操作系统中的**协议栈**。
4. 建立TCP连接
5. 发送数据：TCP -> ip ->MAC ->  网卡 -> 网线(物理层)
6. 服务器处理Http请求，并将数据传输给浏览器
7. 浏览器成功获取Http报文，并将HTML代码解析显示


![[Pasted image 20240418145506.png]]


## 应用层
### HTTP

#### HTTP常见状态码

![[Pasted image 20240418152118.png]]

#### HTTP常见字段

- `Host`：指定服务器的域名
- `Content-Length`：服务器返回数据时，表示本次回应的数据长度
- `Connection`：用于客户端要求服务器使用「HTTP 长连接」机制
- `Content-Type`：服务器回应时，告诉客户端本次数据是什么格式
- `Accept`：客户端告诉服务器，自己可以接受哪些数据格式
- `Content-Encoding`：表示服务器返回的数据使用了什么压缩格式
- `Accept-Encoding`：表示客户端可以接受哪些压缩方法。

#### GET和POST

从RFC规范语义：
- GET：从服务器上获取指定资源，是安全且幂等的
- POST：根据请求内容对指定资源进行处理，是不安全、不幂等的 

GET是可以带body的，只是因为 RFC 规范定义的 GET 请求是获取资源，所以根据这个语义不需要用到 body

#### HTTP缓存技术

1. 强制缓存：浏览器自行决定是否使用缓存（缓存没过期）
	1. `Cache-Control`， 是一个相对时间（推荐）
	2. `Expires`，是一个绝对时间

3. 协商缓存：通过服务器告知客户端是否可以使用缓存

#### HTTP1.1

特点
- 无状态
- 明文传输
- 不安全
	- 通信是明文，可能被窃听
	- 不验证通信双方，可能被伪装
	- 不验证报文完整性，可能被纂改

性能：HTTP 协议是基于 **TCP/IP**，并且使用了「**请求 - 应答**」的通信模式
- 长连接 ：TCP连接一直保持
- 管道网络传输（不常用）：客户端可以发起多个请求，但服务器必须按顺序响应，能解决请求队头阻塞，不能解决响应对头阻塞

「请求 - 应答」的模式会造成 HTTP 的性能问题，因为会造成对头阻塞

#### HTTP和HTTPS 

区别：
- HTTPS再**HTTP和TCP之间**加入了**SSL/TLS**安全协议，解决了HTTP不安全的问题
- HTTPS经过TCP三次握手后，还需要进行SSL/TLS的握手
- HTTP默认端口**80**，HTTPS默认端口**443**
- HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的

HTTPS解决了HTTP不安全的问题
方式：
- 信息加密：混合加密 
- 校验机制：摘要算法
- 身份证书：数字证书

HTTPS本身足够安全，如果用户接受了中间人伪造的证书，会有信息泄露的问题，但这不能说是HTTPS的问题，而是用户本身接受了中间人伪造的证书

#### HTTP2

HTTP2是基于HTTPS的

HTTP2相对于HTTP1.1的改进：
- 头部压缩
- 二进制格式
- 并发传输
- 服务器主动推送资源

缺陷：性能瓶颈在**TCP**

#### HTTP3

采用基于UDP的**QUIC**协议




![[Pasted image 20240418164041.png]]

#### 如何优化HTTP/1.1

- 尽量避免发送HTTP请求：缓存
- 考虑减少发送请求次数：
	- 减少重定向次数
	- 合并请求
	- 延迟发送请求 ：请求网页的时候，没必要把全部资源都获取到，而是只获取当前用户所看到的页面资源
- 如何减少 HTTP 响应的数据大小：
	- 有损压缩
	- 无损压缩

### HTTPS 

#### 完整过程

1. TCP三次握手
2. ClientHello：（TLS版本，随机数， 支持的密码套件）
3. ServerHello：（确认TLS版本，随机数，确认的密码套件列表， 服务器数字证书）
4. 客户端确认服务端数字证书：
	1. 通过浏览器或者操作系统中的 CA 公钥，确认数字证书签名的合法性
	2. 数字证书里面包含了公钥、持有者信息、CA的信息、CA对文件的签名以及使用的算法、证书有效期，数字证书里的数字签名是对文件HASH后使用**私钥加密**的结果，参见[客户端验证证书](https://xiaolincoding.com/network/2_http/https_rsa.html#%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%AA%8C%E8%AF%81%E8%AF%81%E4%B9%A6)
	3. 因此使用CA 公钥进行解密，使用同一HASH算法得到的结果与数字签名比较
5. 客户端取出服务器公钥，使用它加密**随机数**，Finish报文（随机数， 加密通信算法改变通知， 客户端握手结束通知——把之前所有内容的发生的数据做个摘要，用来供服务端校验）
	1. **服务器和客户端有了这三个随机数（Client Random、Server Random、pre-master key），接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」**。
6. 服务端根据三个随机数生成会话密钥，发送Finish报文（加密通信算法改变通知， 服务器握手结束通知——把之前所有内容的发生的数据做个摘要，用来供客户端校验）

以上TLS握手完成，后续就是Http协议，只不过用「会话秘钥」加密内容。

##### 为什么需要三个随机数

确保通信的唯一性和安全性，保护数据的机密性和完整性，通过使用多个随机数，可以增加密钥的复杂性和安全性，提高加密算法的强度，从而更好地保护通信数据。

##### 为什么最后客户端和服务端都要发送一个Finish报文？

Finish报文用来校验双方的身份。

当客户端把这个值通过得到的公钥进行加密的时候，服务器得到之后对其进行解密，然后再对全部报文进行一个HASH求值。如果这个值跟解密得到的值相等的话，那么说明客户端是可信赖的。服务器同理。

#### 会话加密过程

1. 消息分割成多段并压缩
2. 对压缩后的片段加上消息验证码（MAC，通过哈希算法生成）
3. 使用对称密钥加密
4. 附上报头（数据类型，版本号，压缩后的长度），交给TCP传输

##### 为什么分段

GPT：
![[Pasted image 20240529110405.png]]

### DNS

#### 解析过程

1. 先向本地DNS缓存服务器查找
2. 本地服务器向根服务器查找，返回顶级域服务器地址
3. 本地服务器向顶级域服务器查找，返回权威服务器地址
4. 本地服务器向权威服务器查找，返回目标IP地址
5. 本地服务器将IP地址返回主机
> 不是每次都需要经过域名解析，存在缓存，缓存查找顺序：浏览器 -> 操作系统 -> hosts

## 传输层

### TCP 

> TCP：用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括 **Socket、序列号和窗口大小**称为连接。

TCP通过四元组唯一确定一个连接：
- 源地址
- 源端口
- 目的地址
- 目的端口

#### TCP特点

面向连接、可靠、面向字节流

#### 三次握手

1. 客户端发送 （SYN = x），服务端确认**自己**的接收能力和**对方**的发送能力
2. 服务端发送（SYN = y， ACK = x + 1），客户端确认**自己**的发送能力、接收能力和**对方**的发送能力、接收能力，服务端确认**自己**的接收能力和**对方**的发送能力
3. 客户端发送（ACK = y + 1），客户端确认**自己**的发送能力、接收能力和**对方**的发送能力、接收能力，服务端确认**自己**的发送能力、接收能力和**对方**的发送能力、接收能力

三次才能保证完全双方收发能力正常

> 第三次握手可以携带上数据（其本质还是三次握手，并没有减少）

##### 为什么是三次握手

- 防止历史连接初始化了连接（主要原因）
- 同步双方初始序列号
- 避免资源浪费