## 缓存穿透

同一时间大量访问缓存中**不存在的key**，导致大量请求直接打在数据库上，这种现象叫做缓存穿透

解决方案：
1. **把无效的Key存进Redis中**：如果Redis查不到数据，数据库也查不到，我们把这个Key值保存进Redis，设置value="null"，当下次再通过这个Key查询时就不需要再查询数据库。这种处理方式存在问题，假如传进来的这个不存在的Key值每次都是随机的，那存进Redis也没有意义。
2. **使用布隆过滤器**

## 缓存击穿

缓存中的某个热点key失效了，导致大并发集中打在数据库上

解决方案： 
1. 对于热点的key可以设置**永不过期的key**
2. **使用互斥锁**。如果缓存失效的情况，只有拿到锁才可以查询数据库，降低了在同一时刻打在数据库上的请求，防止数据库打死。当然这样会导致系统的性能变差。

## 缓存雪崩

某一个时刻出现大规模的缓存key失效的情况，那么就会导致大量的请求直接打在数据库上面

解决方案： 
1. **在原有的失效时间上加上一个随机值**，比如1-5分钟随机。这样就避免了因为采用相同的过期时间导致的缓存雪崩。
2. 使用**熔断**机制。当流量到达一定的阈值时，就直接返回“系统拥挤”之类的提示，防止过多的请求打在数据库上。至少能保证一部分用户是可以正常使用，其他用户多刷新几次也能得到结果。
3. **提高数据库的容灾能力**，可以使用分库分表，读写分离的策略。
4. 为了防止Redis宕机导致缓存雪崩的问题，可以**搭建Redis集群**，提高Redis的容灾性。