## 问题

当一张数据表写到2kw条数据之后，层级结构就可能会变高，不同层级的数据页一般都放在磁盘里不同的地方，换言之，磁盘IO就会增多，带来的便是查询性能变差。

## 分表

- 垂直分表
	- 将某几列拆成一个新表，使得单行数据表小
	- B+树里的单个数据页（固定16kb）内能放入的行数就会变多，从而使单表能放入更多的数据。
- **水平分表**
	- 将一个`user`表分为`user_0, user1, user2 .... uerN`这样的N多张小表。


- 如果能在**多个数据库**里做分表，这就是所谓的**分库分表**。

### 水平分表

- 根据**id范围**分表
	- ![[Pasted image 20231025192010.png]]
	- 缺点：因为新写入的数都会落在某一张表上，容易出现写热点问题

-  根据**id取模**分表
	- ![[Pasted image 20231025192345.png]]
	- 优点：读写数据都可以很均匀的分摊到每个分表上。
	- 缺点：扩展表的个数困难
- **id范围**和**id取模**结合
	- ![[Pasted image 20231025192506.png]]
	- 在分库的场景下优势会更明显，不同的库，可以把服务部署到不同的机器上，这样各个机器的性能都能被用起来。

## 读扩散问题

- **描述**：查询不一定只查询主键，对于12306问题，可能查询用户名、Email、电话等。假设对用户名分片，查询Email时无法确定去哪个分表上执行sql，此时就要对所有分表**并行**执行sql，随着表越来越多，执行次数会越来越多，这就是所谓的**读扩散问题**。
- **解决**：引入新表来做分表
	- 单独建个**新的分片表**，这个新表里的列就只有旧表的主键id和普通索引列，而这次换普通索引列来做分片键。
	- ![[Pasted image 20231025193313.png]]
	- 缺点：需要维护两套表，并且普通索引列更新时，要两张表同时进行更改，存在一定的并发量。
- **另外解决方案**：
	1. 使用es+mysql
		- es天然支持**倒排索引**，mysql同步es可以通过canal
	2. 使用**tidb**替换mysql，tidb是分布式数据库，且与mysql语法相近